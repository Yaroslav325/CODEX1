<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1.0" />
        <title>City of Text — OMEGA_SYS</title>
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }
            body {
                overflow: hidden;
                background: #000;
                font-family: "Courier New", monospace;
            }
            canvas#gl {
                display: block;
                position: fixed;
                top: 0;
                left: 0;
                z-index: 1;
            }
            #scanlines {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
                z-index: 50;
                background: repeating-linear-gradient(
                    0deg,
                    rgba(0, 0, 0, 0.12) 0px,
                    rgba(0, 0, 0, 0.12) 1px,
                    transparent 1px,
                    transparent 3px
                );
            }
            #vignette {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
                z-index: 49;
                background: radial-gradient(
                    ellipse at center,
                    transparent 30%,
                    rgba(0, 0, 5, 0.85) 100%
                );
            }
            #crosshair {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                z-index: 100;
                pointer-events: none;
                opacity: 0.6;
            }
            #crosshair::before,
            #crosshair::after {
                content: "";
                position: absolute;
                background: #44ddff;
                box-shadow: 0 0 6px #44ddff;
            }
            #crosshair::before {
                width: 20px;
                height: 1px;
                top: 0;
                left: -10px;
            }
            #crosshair::after {
                width: 1px;
                height: 20px;
                top: -10px;
                left: 0;
            }
            #minimap {
                position: fixed;
                top: 12px;
                right: 12px;
                z-index: 120;
                border: 1px solid rgba(0, 255, 100, 0.4);
                box-shadow: 0 0 12px rgba(0, 255, 100, 0.1);
                image-rendering: pixelated;
            }
            #hud-bottom {
                position: fixed;
                bottom: 28px;
                left: 50%;
                transform: translateX(-50%);
                z-index: 120;
                pointer-events: none;
                text-align: center;
            }
            #hud-node {
                color: #77ddcc;
                font-size: 16px;
                letter-spacing: 4px;
                text-shadow:
                    0 0 10px #44aa99,
                    0 0 25px #226655;
            }
            #hud-sub {
                color: #558877;
                font-size: 11px;
                letter-spacing: 3px;
                margin-top: 2px;
            }
            #info {
                position: fixed;
                top: 12px;
                left: 12px;
                color: #33aa77;
                font-size: 12px;
                z-index: 120;
                text-shadow: 0 0 8px #22774480;
                background: rgba(0, 2, 8, 0.8);
                padding: 10px 14px;
                border: 1px solid rgba(0, 255, 100, 0.2);
                line-height: 1.6;
            }
        </style>
    </head>
    <body>
        <canvas id="gl"></canvas>
        <div id="scanlines"></div>
        <div id="vignette"></div>
        <div id="crosshair"></div>
        <canvas id="minimap" width="140" height="140"></canvas>
        <div id="hud-bottom">
            <div id="hud-node">[ OMEGA_SYS ]</div>
            <div id="hud-sub">FINANCIAL DB — NODE 0x4</div>
        </div>
        <div id="info">
            WASD — движение &nbsp;|&nbsp; SHIFT — спринт<br />
            Мышь — осмотр &nbsp;|&nbsp; Клик — захват &nbsp;|&nbsp; ESC — курсор
        </div>

        <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>

        <script>
            (function () {
                "use strict";
                if (typeof THREE === "undefined") {
                    document.body.innerHTML =
                        '<div style="color:#f33;padding:40px;font-family:monospace">Three.js failed to load. Check network.</div>';
                    return;
                }

                // ===================== CONFIG =====================
                const MZ = 25,
                    CS = 5,
                    WH = 14,
                    FDEN = 0.009;
                const SPD = 0.22,
                    SPRINT = 2.8,
                    PHGT = 3.0;
                const PALETTE = [
                    "#2244ff",
                    "#4488ff",
                    "#00ccff",
                    "#6633ff",
                    "#9944ff",
                    "#cc44ff",
                    "#2299aa",
                    "#3366dd",
                    "#00ffcc",
                    "#5577ff",
                ];
                const PALHEX = PALETTE.map((c) => new THREE.Color(c));
                const CHARS =
                    "01アイウエオカキクケコサシスセソ{}[]<>=/\\#$%&@!?";

                // ===================== RENDERER =====================
                const canvas = document.getElementById("gl");
                const renderer = new THREE.WebGLRenderer({
                    canvas,
                    antialias: true,
                    powerPreference: "high-performance",
                });
                renderer.setSize(innerWidth, innerHeight);
                renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
                renderer.toneMapping = THREE.ACESFilmicToneMapping;
                renderer.toneMappingExposure = 1.0;
                renderer.outputEncoding = THREE.sRGBEncoding;

                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x000208);
                scene.fog = new THREE.FogExp2(0x000208, FDEN);

                const camera = new THREE.PerspectiveCamera(
                    72,
                    innerWidth / innerHeight,
                    0.1,
                    600,
                );
                camera.position.set(0, PHGT, 0);

                // ===================== BLOOM =====================
                let composer = null;
                try {
                    composer = new THREE.EffectComposer(renderer);
                    composer.addPass(new THREE.RenderPass(scene, camera));
                    const bloom = new THREE.UnrealBloomPass(
                        new THREE.Vector2(innerWidth, innerHeight),
                        2.0,
                        0.5,
                        0.3,
                    );
                    composer.addPass(bloom);
                } catch (e) {
                    composer = null;
                }

                // ===================== LIGHTS =====================
                scene.add(new THREE.AmbientLight(0x0a0a20, 0.8));
                scene.add(new THREE.HemisphereLight(0x1122aa, 0x000510, 0.4));

                const dynLights = [];
                for (let i = 0; i < 10; i++) {
                    const c = PALHEX[i % PALHEX.length];
                    const pl = new THREE.PointLight(c, 3, 40);
                    pl.position.set(
                        (Math.random() - 0.5) * MZ * CS,
                        2 + Math.random() * 5,
                        (Math.random() - 0.5) * MZ * CS,
                    );
                    scene.add(pl);
                    dynLights.push({
                        l: pl,
                        by: pl.position.y,
                        s: 0.3 + Math.random(),
                        p: Math.random() * 6.28,
                    });
                }

                // ===================== MAZE =====================
                function genMaze(w, h) {
                    const m = Array.from({ length: h }, () =>
                        new Uint8Array(w).fill(1),
                    );
                    const sk = [[1, 1]];
                    m[1][1] = 0;
                    while (sk.length) {
                        const [x, y] = sk[sk.length - 1];
                        const d = [
                            [0, -2],
                            [0, 2],
                            [-2, 0],
                            [2, 0],
                        ];
                        for (let i = d.length - 1; i > 0; i--) {
                            const j = (Math.random() * (i + 1)) | 0;
                            [d[i], d[j]] = [d[j], d[i]];
                        }
                        let f = false;
                        for (const [dx, dy] of d) {
                            const nx = x + dx,
                                ny = y + dy;
                            if (
                                nx > 0 &&
                                nx < w - 1 &&
                                ny > 0 &&
                                ny < h - 1 &&
                                m[ny][nx]
                            ) {
                                m[y + dy / 2][x + dx / 2] = 0;
                                m[ny][nx] = 0;
                                sk.push([nx, ny]);
                                f = true;
                                break;
                            }
                        }
                        if (!f) sk.pop();
                    }
                    return m;
                }
                const maze = genMaze(MZ, MZ);

                // ===================== TEXTURE POOL (fast, NO shadowBlur) =====================
                function makeTextTex(w, h, color) {
                    const c = document.createElement("canvas");
                    c.width = w;
                    c.height = h;
                    const g = c.getContext("2d");
                    // Dark bg
                    g.fillStyle = "#000210";
                    g.fillRect(0, 0, w, h);
                    // Faint h-lines
                    g.strokeStyle = color;
                    g.globalAlpha = 0.04;
                    g.lineWidth = 1;
                    for (let y = 0; y < h; y += 10) {
                        g.beginPath();
                        g.moveTo(0, y);
                        g.lineTo(w, y);
                        g.stroke();
                    }
                    // Characters — NO shadowBlur
                    const fs = 10,
                        step = fs + 2;
                    g.font = fs + "px Courier New";
                    g.textBaseline = "top";
                    for (let y = 0; y < h; y += step) {
                        for (let x = 0; x < w; x += step) {
                            if (Math.random() > 0.2) {
                                g.globalAlpha = 0.15 + Math.random() * 0.5;
                                g.fillStyle = color;
                                g.fillText(
                                    CHARS[(Math.random() * CHARS.length) | 0],
                                    x,
                                    y,
                                );
                            }
                        }
                    }
                    // A few bright white chars
                    g.globalAlpha = 0.9;
                    g.fillStyle = "#fff";
                    for (let i = 0; i < 4; i++)
                        g.fillText(
                            CHARS[(Math.random() * CHARS.length) | 0],
                            (Math.random() * w) | 0,
                            (Math.random() * h) | 0,
                        );
                    const t = new THREE.CanvasTexture(c);
                    t.wrapS = t.wrapT = THREE.RepeatWrapping;
                    return t;
                }

                // Pre-generate a POOL of textures (only 10, reused everywhere)
                const TEX_POOL = [];
                for (let i = 0; i < PALETTE.length; i++) {
                    TEX_POOL.push(makeTextTex(256, 512, PALETTE[i]));
                }

                // Materials pool
                const WALL_MATS = TEX_POOL.map((tex, i) => {
                    return new THREE.MeshStandardMaterial({
                        map: tex,
                        emissive: PALHEX[i],
                        emissiveIntensity: 0.3,
                        emissiveMap: tex,
                        transparent: true,
                        opacity: 0.92,
                        side: THREE.DoubleSide,
                        metalness: 0.15,
                        roughness: 0.75,
                    });
                });

                // ===================== BUILD MAZE =====================
                const wallGeo = new THREE.BoxGeometry(CS, WH, CS);
                const walls = [];
                const edgeGeo = new THREE.EdgesGeometry(wallGeo);

                for (let z = 0; z < MZ; z++) {
                    for (let x = 0; x < MZ; x++) {
                        if (maze[z][x] === 1) {
                            const mi = (Math.random() * WALL_MATS.length) | 0;
                            const w = new THREE.Mesh(wallGeo, WALL_MATS[mi]);
                            w.position.set(
                                (x - MZ / 2) * CS,
                                WH / 2,
                                (z - MZ / 2) * CS,
                            );
                            scene.add(w);
                            walls.push(w);
                            // Edge wireframe
                            const em = new THREE.LineBasicMaterial({
                                color: PALHEX[mi],
                                transparent: true,
                                opacity: 0.2,
                            });
                            const el = new THREE.LineSegments(edgeGeo, em);
                            el.position.copy(w.position);
                            scene.add(el);
                        }
                    }
                }

                // ===================== FLOOR =====================
                const FS = MZ * CS * 2;
                const floorGeo = new THREE.PlaneGeometry(FS, FS);
                const floorMat = new THREE.MeshStandardMaterial({
                    color: 0x020210,
                    metalness: 0.95,
                    roughness: 0.1,
                });
                const floor = new THREE.Mesh(floorGeo, floorMat);
                floor.rotation.x = -Math.PI / 2;
                floor.position.y = -0.02;
                scene.add(floor);

                // Grid lines
                const gp = [];
                const ge = FS / 2;
                for (let i = -ge; i <= ge; i += CS) {
                    gp.push(-ge, 0.02, i, ge, 0.02, i);
                    gp.push(i, 0.02, -ge, i, 0.02, ge);
                }
                const gg = new THREE.BufferGeometry();
                gg.setAttribute(
                    "position",
                    new THREE.Float32BufferAttribute(gp, 3),
                );
                scene.add(
                    new THREE.LineSegments(
                        gg,
                        new THREE.LineBasicMaterial({
                            color: 0x1144aa,
                            transparent: true,
                            opacity: 0.15,
                        }),
                    ),
                );

                // ===================== LIGHT COLUMNS =====================
                const lightCols = [];
                for (let i = 0; i < 15; i++) {
                    const ch = 25 + Math.random() * 35,
                        cw = 0.5 + Math.random() * 1.2;
                    const geo = new THREE.CylinderGeometry(
                        cw,
                        cw * 0.3,
                        ch,
                        6,
                        1,
                        true,
                    );
                    const col = PALHEX[(Math.random() * PALHEX.length) | 0];
                    const mat = new THREE.MeshBasicMaterial({
                        color: col,
                        transparent: true,
                        opacity: 0.05,
                        side: THREE.DoubleSide,
                        blending: THREE.AdditiveBlending,
                        depthWrite: false,
                    });
                    const m = new THREE.Mesh(geo, mat);
                    m.position.set(
                        (Math.random() - 0.5) * MZ * CS * 1.1,
                        ch / 2,
                        (Math.random() - 0.5) * MZ * CS * 1.1,
                    );
                    scene.add(m);
                    lightCols.push({
                        m,
                        ph: Math.random() * 6.28,
                        sp: 0.3 + Math.random() * 0.7,
                    });
                }

                // ===================== TOWERS =====================
                // Reuse pool textures for towers too
                for (let i = 0; i < 40; i++) {
                    const h = 20 + Math.random() * 60,
                        tw = 3 + Math.random() * 6,
                        td = 3 + Math.random() * 6;
                    const ti = (Math.random() * TEX_POOL.length) | 0;
                    const mat = new THREE.MeshStandardMaterial({
                        map: TEX_POOL[ti],
                        emissive: PALHEX[ti],
                        emissiveIntensity: 0.12,
                        transparent: true,
                        opacity: 0.7,
                        metalness: 0.2,
                        roughness: 0.7,
                    });
                    const t = new THREE.Mesh(
                        new THREE.BoxGeometry(tw, h, td),
                        mat,
                    );
                    const a = Math.random() * Math.PI * 2;
                    const dist = MZ * CS * 0.55 + Math.random() * MZ * CS * 0.6;
                    t.position.set(
                        Math.cos(a) * dist,
                        h / 2,
                        Math.sin(a) * dist,
                    );
                    scene.add(t);
                    if (Math.random() > 0.5) {
                        const eg2 = new THREE.EdgesGeometry(t.geometry);
                        const el2 = new THREE.LineSegments(
                            eg2,
                            new THREE.LineBasicMaterial({
                                color: PALHEX[ti],
                                transparent: true,
                                opacity: 0.25,
                            }),
                        );
                        el2.position.copy(t.position);
                        scene.add(el2);
                    }
                }

                // ===================== DATA STREAMS (simple quads) =====================
                const streams = [];
                const streamGeo = new THREE.PlaneGeometry(0.4, 5);
                for (let i = 0; i < 120; i++) {
                    const ci = (Math.random() * PALHEX.length) | 0;
                    const mat = new THREE.MeshBasicMaterial({
                        color: PALHEX[ci],
                        transparent: true,
                        opacity: 0.15,
                        side: THREE.DoubleSide,
                        blending: THREE.AdditiveBlending,
                        depthWrite: false,
                    });
                    const m = new THREE.Mesh(streamGeo, mat);
                    m.position.set(
                        (Math.random() - 0.5) * MZ * CS * 1.3,
                        8 + Math.random() * 30,
                        (Math.random() - 0.5) * MZ * CS * 1.3,
                    );
                    m.userData = {
                        spd: 0.04 + Math.random() * 0.1,
                        rh: 35 + Math.random() * 15,
                    };
                    scene.add(m);
                    streams.push(m);
                }

                // ===================== PARTICLES =====================
                const PCNT = 1200;
                const pGeo = new THREE.BufferGeometry();
                const pPos = new Float32Array(PCNT * 3),
                    pCol = new Float32Array(PCNT * 3);
                for (let i = 0; i < PCNT; i++) {
                    pPos[i * 3] = (Math.random() - 0.5) * FS;
                    pPos[i * 3 + 1] = Math.random() * 45;
                    pPos[i * 3 + 2] = (Math.random() - 0.5) * FS;
                    const c = PALHEX[(Math.random() * PALHEX.length) | 0];
                    pCol[i * 3] = c.r;
                    pCol[i * 3 + 1] = c.g;
                    pCol[i * 3 + 2] = c.b;
                }
                pGeo.setAttribute(
                    "position",
                    new THREE.BufferAttribute(pPos, 3),
                );
                pGeo.setAttribute("color", new THREE.BufferAttribute(pCol, 3));
                const particles = new THREE.Points(
                    pGeo,
                    new THREE.PointsMaterial({
                        size: 0.2,
                        vertexColors: true,
                        transparent: true,
                        opacity: 0.7,
                        blending: THREE.AdditiveBlending,
                        sizeAttenuation: true,
                        depthWrite: false,
                    }),
                );
                scene.add(particles);

                // ===================== NEON TUBES =====================
                const tubeGeo = new THREE.CylinderGeometry(0.06, 0.06, 1, 5);
                for (let i = 0; i < 35; i++) {
                    const len = 3 + Math.random() * 10;
                    const ci = (Math.random() * PALHEX.length) | 0;
                    const mat = new THREE.MeshBasicMaterial({
                        color: PALHEX[ci],
                        transparent: true,
                        opacity: 0.8,
                    });
                    const t = new THREE.Mesh(tubeGeo, mat);
                    t.scale.y = len;
                    t.position.set(
                        (Math.random() - 0.5) * FS * 0.4,
                        1 + Math.random() * 16,
                        (Math.random() - 0.5) * FS * 0.4,
                    );
                    if (Math.random() > 0.5) t.rotation.z = Math.PI / 2;
                    else t.rotation.x = Math.PI / 2;
                    scene.add(t);
                }

                // ===================== HOLOGRAMS =====================
                const holos = [];
                const holoGeos = [
                    new THREE.IcosahedronGeometry(0.7, 0),
                    new THREE.OctahedronGeometry(0.7, 0),
                    new THREE.TorusGeometry(0.5, 0.18, 6, 10),
                    new THREE.TetrahedronGeometry(0.7, 0),
                ];
                for (let i = 0; i < 15; i++) {
                    const g = holoGeos[(Math.random() * holoGeos.length) | 0];
                    const c = PALHEX[(Math.random() * PALHEX.length) | 0];
                    const m = new THREE.Mesh(
                        g,
                        new THREE.MeshBasicMaterial({
                            color: c,
                            wireframe: true,
                            transparent: true,
                            opacity: 0.5,
                        }),
                    );
                    m.position.set(
                        (Math.random() - 0.5) * MZ * CS * 0.8,
                        2 + Math.random() * 9,
                        (Math.random() - 0.5) * MZ * CS * 0.8,
                    );
                    m.userData = {
                        rx: (Math.random() - 0.5) * 0.025,
                        ry: (Math.random() - 0.5) * 0.03,
                        by: m.position.y,
                        fs: 0.4 + Math.random(),
                        fo: Math.random() * 6.28,
                    };
                    scene.add(m);
                    holos.push(m);
                }

                // ===================== MINIMAP =====================
                const mmC = document.getElementById("minimap"),
                    mmG = mmC.getContext("2d");
                const mmS = mmC.width / MZ;
                // Pre-draw static maze part
                const mmStatic = document.createElement("canvas");
                mmStatic.width = mmC.width;
                mmStatic.height = mmC.height;
                const mmSG = mmStatic.getContext("2d");
                mmSG.fillStyle = "rgba(0,2,8,.92)";
                mmSG.fillRect(0, 0, mmC.width, mmC.height);
                for (let z = 0; z < MZ; z++)
                    for (let x = 0; x < MZ; x++) {
                        if (maze[z][x] === 1) {
                            mmSG.fillStyle = "#1a5533";
                            mmSG.fillRect(x * mmS, z * mmS, mmS, mmS);
                        }
                    }

                function drawMM() {
                    mmG.drawImage(mmStatic, 0, 0);
                    const px = (camera.position.x / CS + MZ / 2) * mmS;
                    const pz = (camera.position.z / CS + MZ / 2) * mmS;
                    mmG.fillStyle = "#00ff66";
                    mmG.beginPath();
                    mmG.arc(px, pz, 2.5, 0, 6.28);
                    mmG.fill();
                    mmG.strokeStyle = "#00ff66";
                    mmG.lineWidth = 1.5;
                    mmG.beginPath();
                    mmG.moveTo(px, pz);
                    mmG.lineTo(px - Math.sin(yaw) * 7, pz - Math.cos(yaw) * 7);
                    mmG.stroke();
                }

                // ===================== HUD =====================
                const NODES = [
                    "OMEGA_SYS",
                    "NEXUS_CORE",
                    "CIPHER_NET",
                    "SHADOW_DB",
                    "QUANTUM_IO",
                    "GENESIS_MX",
                ];
                const SUBS = [
                    "FINANCIAL DB — NODE 0x4",
                    "SECURITY LAYER 7",
                    "DATA STREAM ACTIVE",
                    "ENCRYPTION MATRIX",
                    "NEURAL PATHWAY 0xF3",
                ];
                let hudT = 0;
                function updHUD(t) {
                    if (t - hudT > 8) {
                        hudT = t;
                        document.getElementById("hud-node").textContent =
                            "[ " +
                            NODES[(Math.random() * NODES.length) | 0] +
                            " ]";
                        document.getElementById("hud-sub").textContent =
                            SUBS[(Math.random() * SUBS.length) | 0];
                    }
                }

                // ===================== CONTROLS =====================
                const keys = {};
                const dir = new THREE.Vector3();
                let yaw = 0,
                    pitch = 0;
                addEventListener("keydown", (e) => {
                    keys[e.code] = true;
                    if (
                        [
                            "KeyW",
                            "KeyS",
                            "KeyA",
                            "KeyD",
                            "ArrowUp",
                            "ArrowDown",
                            "ArrowLeft",
                            "ArrowRight",
                            "ShiftLeft",
                            "ShiftRight",
                        ].includes(e.code)
                    )
                        e.preventDefault();
                });
                addEventListener("keyup", (e) => (keys[e.code] = false));
                document.body.addEventListener("click", () =>
                    renderer.domElement.requestPointerLock(),
                );
                document.addEventListener("mousemove", (e) => {
                    if (document.pointerLockElement === renderer.domElement) {
                        yaw -= e.movementX * 0.002;
                        pitch = Math.max(
                            -Math.PI / 2,
                            Math.min(Math.PI / 2, pitch - e.movementY * 0.002),
                        );
                    }
                });

                // ===================== COLLISION =====================
                function blocked(p) {
                    const gx = Math.floor((p.x + (MZ * CS) / 2) / CS),
                        gz = Math.floor((p.z + (MZ * CS) / 2) / CS),
                        r = 0.55;
                    for (let dz = -1; dz <= 1; dz++)
                        for (let dx = -1; dx <= 1; dx++) {
                            const cx = gx + dx,
                                cz = gz + dz;
                            if (
                                cx >= 0 &&
                                cx < MZ &&
                                cz >= 0 &&
                                cz < MZ &&
                                maze[cz][cx] === 1
                            ) {
                                const wx = (cx - MZ / 2) * CS,
                                    wz = (cz - MZ / 2) * CS,
                                    hc = CS / 2;
                                if (
                                    p.x > wx - hc - r &&
                                    p.x < wx + hc + r &&
                                    p.z > wz - hc - r &&
                                    p.z < wz + hc + r
                                )
                                    return true;
                            }
                        }
                    return false;
                }

                // ===================== START =====================
                camera.position.set(
                    (-MZ / 2 + 1.5) * CS,
                    PHGT,
                    (-MZ / 2 + 1.5) * CS,
                );

                // ===================== LOOP =====================
                let prevT = performance.now();
                function loop() {
                    requestAnimationFrame(loop);
                    const now = performance.now(),
                        dt = (now - prevT) / 1000;
                    prevT = now;
                    const t = now * 0.001;

                    camera.rotation.order = "YXZ";
                    camera.rotation.y = yaw;
                    camera.rotation.x = pitch;

                    dir.set(0, 0, 0);
                    if (keys.KeyW || keys.ArrowUp) dir.z -= 1;
                    if (keys.KeyS || keys.ArrowDown) dir.z += 1;
                    if (keys.KeyA || keys.ArrowLeft) dir.x -= 1;
                    if (keys.KeyD || keys.ArrowRight) dir.x += 1;
                    if (dir.length() > 0) {
                        const sp =
                            keys.ShiftLeft || keys.ShiftRight
                                ? SPD * SPRINT
                                : SPD;
                        dir.normalize().applyAxisAngle(
                            new THREE.Vector3(0, 1, 0),
                            yaw,
                        );
                        const tx = camera.position.clone();
                        tx.x += dir.x * sp;
                        const tz = camera.position.clone();
                        tz.z += dir.z * sp;
                        if (!blocked(tx)) camera.position.x = tx.x;
                        if (!blocked(tz)) camera.position.z = tz.z;
                    }
                    camera.position.y =
                        PHGT +
                        (dir.length() > 0
                            ? Math.sin(t * 8) * 0.05
                            : Math.sin(t * 1.5) * 0.02);

                    // Lights
                    dynLights.forEach((d, i) => {
                        d.l.position.y = d.by + Math.sin(t * d.s + d.p) * 2;
                        d.l.intensity = 2.5 + Math.sin(t * 1.5 + i * 0.7) * 1.2;
                    });

                    // Columns
                    lightCols.forEach((c) => {
                        c.m.material.opacity =
                            0.03 + Math.sin(t * c.sp + c.ph) * 0.025;
                    });

                    // Streams
                    streams.forEach((s) => {
                        s.position.y -= s.userData.spd;
                        s.lookAt(camera.position);
                        if (s.position.y < -2) s.position.y = s.userData.rh;
                    });

                    // Holograms
                    holos.forEach((h) => {
                        h.rotation.x += h.userData.rx;
                        h.rotation.y += h.userData.ry;
                        h.position.y =
                            h.userData.by +
                            Math.sin(t * h.userData.fs + h.userData.fo) * 0.5;
                    });

                    // Particles
                    const pa = particles.geometry.attributes.position.array;
                    for (let i = 0; i < PCNT; i++) {
                        pa[i * 3 + 1] -= 0.025;
                        if (pa[i * 3 + 1] < -1) pa[i * 3 + 1] = 45;
                    }
                    particles.geometry.attributes.position.needsUpdate = true;

                    // Walls
                    for (let i = 0; i < walls.length; i++) {
                        walls[i].material.emissiveIntensity =
                            0.25 + Math.sin(t * 0.4 + i * 0.08) * 0.12;
                    }

                    updHUD(t);
                    drawMM();

                    if (composer) composer.render();
                    else renderer.render(scene, camera);
                }
                loop();
                console.log("OMEGA_SYS online.");
            })();
        </script>
    </body>
</html>
